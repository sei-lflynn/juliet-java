 # SonarCloud analysis for this Java repo
# -----------------------------------------------------------------------------
# What this does:
#   1) Builds the code with a Java-centric SonarCloud workflow that uses the Sonar Ant scanner
#   2) Runs the SonarCloud scanner
#   3) Waits for analysis to finish, pulls issues from SonarCloud's API,
#      converts to SARIF, uploads as an artifact
#   4) Publishes the SARIF to GitHub Code Scanning in a separate, least-privilege job
#
# Why it looks this way (key principles):
#   • Default‑deny permissions – read‑only by default; elevate only in the upload job
#   • Pinned actions – commit SHAs, not floating tags, for reproducibility and tamper‑resistance
#   • Hardened egress – audit (or block) network calls to limit exfiltration risk
#   • Concurrency – cancel superseded runs to save time and money
#   • Timeouts – fail fast instead of hanging for hours
#   • Scoped checkout credentials – don't persist the GitHub token into the repo
#   • Clear triggers – run only when relevant files change
#
# Prereqs in the repo:
#   • sonar-project.properties with:
#       sonar.projectKey=<your_sonarcloud_project_key>
#       sonar.organization=<your_sonarcloud_org_key>
#       sonar.sources=.
#
# Secret needed:
#   • SONAR_TOKEN (Actions → Secrets) – a SonarCloud user token with access to the project

# SonarCloud analysis for a Java/Ant repo (hardened + least privilege)
# ---------------------------------------------------------------------

# SonarCloud analysis for an Ant-based Java repo (Juliet Java v1.3)
# Hardened egress, default-deny perms, scoped checkout, concurrency, SARIF upload

name: SonarCloud (Java - Ant)

on:
  push:
    branches: [ "main" ]
    paths:
      - "**/*.java"
      - "build.xml"
      - "sonar-project.properties"
      - "**/sonar-project.properties"
      - ".github/workflows/sonarcloud.yml"
  pull_request:
    branches: [ "main" ]
    types: [opened, synchronize, reopened]
    paths:
      - "**/*.java"
      - "build.xml"
      - "sonar-project.properties"
      - "**/sonar-project.properties"
      - ".github/workflows/**"
  workflow_dispatch:

# Cancel older in-flight runs on same ref
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

# Default-deny: read-only at workflow level
permissions:
  contents: read

jobs:
  build-and-analyze:
    name: Ant build + SonarCloud + SARIF artifact
    runs-on: ubuntu-24.04
    timeout-minutes: 200
    permissions:
      contents: read

    env:
      # Optional: set a fallback for binaries if you know it (adjust if Juliet uses a different dir)
      FALLBACK_BIN: build/classes

    steps:
      - name: Harden runner (audit egress)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit
          # When stable, consider:
          # egress-policy: block
          # allowed-endpoints: >
          #   sonarcloud.io
          #   api.sonarcloud.io
          #   binaries.sonarsource.com
          #   github.com
          #   api.github.com
          #   uploads.github.com
          #   objects.githubusercontent.com

      - name: Checkout (no persisted creds)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Set up JDK 17
        uses: actions/setup-java@dded0888837ed1f317902acf8a20df0ad188d165 # v5
        with:
          distribution: temurin
          java-version: '17'
          # IMPORTANT: no 'cache: maven' since this repo has no pom.xml

      - name: Ensure Ant is available
        run: |
          set -eux
          if ! command -v ant >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y ant
          fi
          ant -version
          java -version

      - name: Build with Ant
        run: |
          set -euxo pipefail
          # Use the repo's default Ant target (build.xml in repo root)
          # If your build needs a specific target, replace the plain 'ant' with 'ant compile' or similar.
          ant -noinput -buildfile build.xml

      - name: Gather Java bytecode for Sonar (Juliet)
        id: bins
        run: |
          set -euo pipefail
          OUT="build/sonar-classes"
          rm -rf "$OUT" && mkdir -p "$OUT"

          echo "::group::Search for loose .class files"
          mapfile -t CLASS_FILES < <(find . -type f -name '*.class' -print || true)
          echo "Found ${#CLASS_FILES[@]} loose .class files"
          for f in "${CLASS_FILES[@]}"; do
            dest="$OUT/${f#./}"
            mkdir -p "$(dirname "$dest")"
            cp -p "$f" "$dest"
          done
          echo "::endgroup::"

          if ! find "$OUT" -type f -name '*.class' -print -quit | grep -q .; then
            echo "::group::No loose classes; extracting from WAR/JAR artifacts"
            # Unpack classes from WARs (WEB-INF/classes) and JARs produced by sub-builds
            while IFS= read -r -d '' a; do
              case "$a" in
                *.war) unzip -q -o "$a" 'WEB-INF/classes/*' -d "$OUT/unpack" || true ;;
                *.jar) unzip -q -o "$a" -d "$OUT/unpack" || true ;;
              esac
            done < <(find . -type f \( -name '*.war' -o -name '*.jar' \) -print0 || true)

            if [ -d "$OUT/unpack" ]; then
              rsync -a "$OUT/unpack/" "$OUT/" && rm -rf "$OUT/unpack"
            fi
            echo "::endgroup::"
          fi

          # Final check
          if ! find "$OUT" -type f -name '*.class' -print -quit | grep -q .; then
            echo "Still no .class files after build + extraction." >&2
            echo "Tip: ensure Ant actually compiles (e.g., 'ant compile' or 'ant jar')." >&2
            exit 1
          fi

          echo "JAVA_BINARIES=$OUT" >> "$GITHUB_ENV"

          # Optional: provide libraries to improve type resolution
          LIBS=$(find lib -type f -name '*.jar' -printf '%p,' 2>/dev/null | sed 's/,$//')
          if [ -n "$LIBS" ]; then
            echo "JAVA_LIBS=$LIBS" >> "$GITHUB_ENV"
          fi

      - name: SonarCloud scan (CLI scanner)
        uses: SonarSource/sonarqube-scan-action@1a6d90ebcb0e6a6b1d87e37ba693fe453195ae25 # v5.3.1
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          # Let sonar-project.properties provide org/project; pass compiled classes explicitly
          args: >
            --define sonar.java.binaries=${{ env.JAVA_BINARIES }}
            --define sonar.java.libraries=${{ env.JAVA_LIBS || 'lib/**/*.jar' }}

      - name: Generate SARIF from SonarCloud issues
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import base64, json, os, time, urllib.parse, urllib.request, pathlib

          def read_project_key():
              with open("sonar-project.properties", "r", encoding="utf-8") as f:
                  for line in f:
                      line=line.strip()
                      if line.startswith("sonar.projectKey="):
                          return line.split("=",1)[1].strip()
              raise RuntimeError("sonar.projectKey not found in sonar-project.properties")

          def get_json(url, token):
              req = urllib.request.Request(url)
              auth = base64.b64encode((token + ":").encode()).decode()
              req.add_header("Authorization", "Basic " + auth)
              with urllib.request.urlopen(req, timeout=30) as r:
                  return json.load(r)

          base = "https://sonarcloud.io"
          token = os.environ["SONAR_TOKEN"]
          project_key = read_project_key()
          print(f"Project: {project_key}")

          # Wait for latest Compute Engine task to finish
          for _ in range(120):
              act = get_json(f"{base}/api/ce/activity?component={urllib.parse.quote(project_key)}&onlyCurrents=true&ps=1", token)
              tasks = act.get("tasks", [])
              if tasks:
                  tid = tasks[0]["id"]
                  ce = get_json(f"{base}/api/ce/task?id={tid}", token)
                  status = ce["task"]["status"]
                  print(f"CE status: {status}")
                  if status in ("SUCCESS", "FAILED", "CANCELED"):
                      break
              else:
                  print("No CE tasks yet")
              time.sleep(3)

          # Pull unresolved issues
          p=1; page_size=500; issues=[]
          while True:
              data = get_json(f"{base}/api/issues/search?componentKeys={urllib.parse.quote(project_key)}&resolved=false&ps={page_size}&p={p}", token)
              batch = data.get("issues", [])
              if not batch:
                  break
              issues.extend(batch)
              total = data.get("total", 0)
              if p*page_size >= total:
                  break
              p += 1

          def level(sev):
              return {"BLOCKER":"error","CRITICAL":"error","MAJOR":"warning","MINOR":"note","INFO":"note"}.get(sev,"warning")

          runs = [{
              "tool": {"driver": {"name": "SonarCloud", "informationUri": "https://sonarcloud.io", "rules": []}},
              "results": []
          }]
          rule_added=set()
          for it in issues:
              rid = str(it.get("rule","unknown"))
              if rid not in rule_added:
                  runs[0]["tool"]["driver"]["rules"].append({
                      "id": rid,
                      "shortDescription": {"text": (it.get("message","") or "")[:120]}
                  }); rule_added.add(rid)
              comp = it.get("component",""); path = comp.split(":",1)[1] if ":" in comp else comp
              tr = it.get("textRange") or {}; sl = tr.get("startLine", 1)
              sc = (tr.get("startOffset",0) or 0) + 1; el = tr.get("endLine", sl); ec = max(tr.get("endOffset", sc), sc)
              runs[0]["results"].append({
                  "ruleId": rid, "level": level(it.get("severity","MAJOR")),
                  "message": {"text": it.get("message","")},
                  "locations": [{"physicalLocation": {"artifactLocation": {"uri": path, "uriBaseId": "PROJECT_ROOT"}, "region": {"startLine": sl, "startColumn": sc, "endLine": el, "endColumn": ec}}}],
                  "fingerprints": {"sonarIssueKey": it.get("key","")}
              })

          pathlib.Path("reports").mkdir(parents=True, exist_ok=True)
          sarif = {"version":"2.1.0", "$schema":"https://json.schemastore.org/sarif-2.1.0.json", "runs": runs}
          with open("reports/sonarcloud.sarif","w",encoding="utf-8") as f: json.dump(sarif, f, ensure_ascii=False)
          print(f"Wrote {len(issues)} issues to reports/sonarcloud.sarif")
          PY

      - name: Upload SARIF as artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: sonarcloud-sarif
          path: reports/sonarcloud.sarif
          retention-days: 7
          if-no-files-found: error

  upload-to-code-scanning:
    name: Publish SARIF to Code Scanning
    needs: build-and-analyze
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    permissions:
      contents: read
      security-events: write
      actions: read
    steps:
      - name: Harden runner (audit egress)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Download SARIF artifact
        uses: actions/download-artifact@v5
        with:
          name: sonarcloud-sarif
          path: reports

      - name: Upload SARIF to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@3c3833e0f8c1c83d449a7478aa59c036a9165498 # v3.29.11
        with:
          sarif_file: reports/sonarcloud.sarif
          category: sonarcloud
